// Generated by CoffeeScript 1.4.0

/*
An ArrayList stores a variable number of objects. This is similar to making an array of
objects, but with an ArrayList, items can be easily added and removed from the ArrayList
and it is resized dynamically. This can be very convenient, but it's slower than making
an array of objects when using many elements.
*/


(function() {
  var ArrayList, Color, Point, Rectangle, TreeView, namespace,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ArrayList = (function() {
    /*
      Initializes a new instance of the ArrayList class that is empty and has
      the default initial capacity.
    */

    function ArrayList() {
      this.increment = 10;
      this.size = 0;
      this.data = new Array(this.increment);
    }

    ArrayList.prototype.reverse = function() {
      var i, newData, _i, _ref;
      newData = new Array(this.size);
      for (i = _i = 0, _ref = this.size; _i < _ref; i = _i += 1) {
        newData[i] = this.data[this.size - i - 1];
      }
      this.data = newData;
      return this;
    };

    ArrayList.prototype.getCapacity = function() {
      return this.data.length;
    };

    ArrayList.prototype.getSize = function() {
      return this.size;
    };

    ArrayList.prototype.isEmpty = function() {
      return this.getSize() === 0;
    };

    ArrayList.prototype.getLastElement = function() {
      var _ref;
      return (_ref = this.data[this.getSize() - 1]) != null ? _ref : null;
    };

    ArrayList.prototype.asArray = function() {
      this.trimToSize();
      return this.data;
    };

    ArrayList.prototype.getFirstElement = function() {
      var _ref;
      return (_ref = this.data[0]) != null ? _ref : null;
    };

    ArrayList.prototype.get = function(index) {
      return this.data[index];
    };

    ArrayList.prototype.add = function(obj) {
      if (this.getSize() === this.data.length) {
        this.resize();
      }
      this.data[this.size++] = obj;
      return this;
    };

    ArrayList.prototype.addAll = function(list) {
      var i, _i, _ref;
      if (!(list instanceof ArrayList)) {
        throw "Unable to handle unknown object type in ArrayList.addAll";
      }
      for (i = _i = 0, _ref = list.getSize(); _i < _ref; i = _i += 1) {
        this.add(list.get(i));
      }
      return this;
    };

    ArrayList.prototype.remove = function(obj) {
      var index;
      index = this.indexOf(obj);
      if (index >= 0) {
        return this.removeElementAt(index);
      } else {
        return null;
      }
    };

    ArrayList.prototype.insertElementAt = function(obj, index) {
      var i, _i, _ref;
      if (this.size === this.capacity) {
        this.resize();
      }
      for (i = _i = _ref = this.getSize(); _i > index; i = _i += -1) {
        this.data[i] = this.data[i - 1];
      }
      this.data[index] = obj;
      this.size++;
      return this;
    };

    ArrayList.prototype.removeElementAt = function(index) {
      var element, i, _i, _ref;
      element = this.data[index];
      for (i = _i = index, _ref = this.getSize() - 1; _i < _ref; i = _i += 1) {
        this.data[i] = this.data[i + i];
      }
      this.data[this.getSize() - 1] = null;
      this.size--;
      return element;
    };

    ArrayList.prototype.removeAllElements = function() {
      var i, _i, _len, _ref;
      this.size = 0;
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        this.data[i] = null;
      }
      return this;
    };

    ArrayList.prototype.indexOf = function(obj) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = this.getSize(); _i < _ref; i = _i += 1) {
        if (this.data[i] === obj) {
          return i;
        }
      }
      return -1;
    };

    ArrayList.prototype.contains = function(obj) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = this.getSize(); _i < _ref; i = _i += 1) {
        if (this.data[i] === obj) {
          return true;
        }
      }
      return false;
    };

    ArrayList.prototype.resize = function() {
      var i, item, newData, _i, _len, _ref;
      newData = new Array(this.data.length + this.increment);
      _ref = this.data;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        item = _ref[i];
        newData[i] = item;
      }
      this.data = newData;
      return this;
    };

    ArrayList.prototype.trimToSize = function() {
      var i, trim, _i, _ref;
      if (this.data.length === this.size) {
        return;
      }
      trim = new Array(this.getSize());
      for (i = _i = 0, _ref = this.getSize(); _i < _ref; i = _i += 1) {
        trim[i] = this.data[i];
      }
      this.size = trim.length;
      this.data = trim;
      return this;
    };

    ArrayList.prototype.clone = function() {
      var newList;
      newList = new ArrayList(this.size);
      newList.addAll(this);
      return newList;
    };

    ArrayList.prototype.sort = function(cmp) {
      this.trimToSize();
      return this.data = _.sortBy(this.data, cmp);
    };

    ArrayList.prototype.each = function(func) {
      var i, _i, _ref, _results;
      if (typeof func !== 'function') {
        throw "Parameter must be type of function";
      }
      _results = [];
      for (i = _i = 0, _ref = this.getSize(); _i < _ref; i = _i += 1) {
        if (func(i, this.data[i]) === false) {
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ArrayList.prototype.overwriteElementAt = function(obj, index) {
      this.data[index] = obj;
      return this;
    };

    return ArrayList;

  })();

  /*
  Util class to handle colors
  */


  Color = (function() {
    var hex2rgb, int2hex;

    function Color(red, green, blue) {
      var rgb;
      if (green == null) {
        rgb = hex2rgb(red);
        this.red = rgb[0];
        this.green = rgb[1];
        this.blue = rgb[2];
      } else {
        this.red = red;
        this.green = green;
        this.blue = blue;
      }
    }

    Color.prototype.getHTMLStyle = function() {
      return "rbg(" + this.red + ", " + this.green + ", " + this.blue + ")";
    };

    Color.prototype.getHashStyle = function() {
      return "#" + (this.hex());
    };

    Color.prototype.getRed = function() {
      return this.red;
    };

    Color.prototype.getGreen = function() {
      return this.green;
    };

    Color.prototype.getBlue = function() {
      return this.blue;
    };

    /*
      Returns the ideal Text Color. Useful for font color selection by
      a given background color.
    */


    Color.prototype.getIdealTextColor = function() {
      var bgDelta, nTreshold;
      nTreshold = 105;
      bgDelta = this.red * 0.299 + this.green * 0.587 + this.blue * 0.114;
      if (255 - bgDelta < nTreshold) {
        return new Color(0, 0, 0);
      } else {
        return new Color(255, 255, 255);
      }
    };

    hex2rgb = function(hexcolor) {
      hexcolor = hexcolor.replace('#', '');
      return {
        0: parseInt(hexcolor.substr(0, 2), 16),
        1: parseInt(hexcolor.substr(2, 2), 16),
        2: parseInt(hexcolor.substr(4, 2), 16)
      };
    };

    Color.prototype.hex = function() {
      return int2hex(this.red) + int2hex(this.green) + int2hex(this.blue);
    };

    int2hex = function(c) {
      c = Math.round(Math.min(Math.max(0, c), 255));
      return "0123456789ABCDEF".charAt((c - c % 16) / 16) + "0123456789ABCDEF".charAt(c % 16);
    };

    Color.colorize = function(color) {
      if (color instanceof Color) {
        return color;
      } else if (typeof color === 'string') {
        return new Color(color);
      }
      return null;
    };

    return Color;

  })();

  Point = (function() {

    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    return Point;

  })();

  Rectangle = (function() {

    function Rectangle(x, y, width, height) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }

    Rectangle.prototype.getBottom = function() {
      return this.y + this.height;
    };

    Rectangle.prototype.getRight = function() {
      return this.x + this.width;
    };

    return Rectangle;

  })();

  /*
  Main namespace for tree rendering
  */


  TreeView = (function() {

    TreeView.Shape = {};

    TreeView.Style = {};

    TreeView.Layout = {};

    TreeView.Connection = {};

    function TreeView(canvasId) {
      this.canvasId = canvasId;
      this.canvas = new TreeView.Canvas(this.canvasId);
      this.trees = [];
      this.displayedNodes = {};
      this.displayedFigures = {};
    }

    TreeView.prototype.renderBundle = function(bundle) {
      var T, label, layer, layout, tree, zone, _ref, _ref1;
      layout = new TreeView.Layout.GridLayout(this.canvas);
      this.trees = [];
      layout.disableReordering();
      this.canvas.setLayout(layout);
      _ref = bundle.zones;
      for (label in _ref) {
        zone = _ref[label];
        _ref1 = zone.trees;
        for (layer in _ref1) {
          tree = _ref1[layer];
          T = new TreeView.Tree(layer, tree);
          _.extend(this.displayedNodes, tree.index);
          _.extend(this.displayedFigures, T.figures);
          this.trees.push(T);
          this.canvas.addFigure(T);
        }
      }
      this.showAlignment();
      layout.enableReordering();
      layout.reorderFigures();
      this.canvas.adjustSize();
    };

    TreeView.prototype.showAlignment = function() {
      var T, alignment, arrows, node, sourceFig, target, targetFig, targetId, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      arrows = [];
      _ref = this.trees;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        T = _ref[_i];
        _ref1 = T.tree.allNodes();
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          node = _ref1[_j];
          if (node.attr('alignment') == null) {
            continue;
          }
          _ref2 = node.attr('alignment');
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            alignment = _ref2[_k];
            targetId = alignment['#value']['counterpart.rf'];
            target = this.displayedNodes[targetId];
            if (!target) {
              continue;
            }
            sourceFig = this.displayedFigures[node.uid];
            targetFig = this.displayedFigures[target.uid];
            if (!((sourceFig != null) && (targetFig != null))) {
              continue;
            }
            TreeView.Style.TreexStylesheet.prototype.drawArrow(sourceFig, targetFig, 'alignment');
          }
        }
      }
    };

    return TreeView;

  })();

  namespace = typeof exports !== "undefined" && exports !== null ? exports : this;

  namespace.Treex.TreeView = function(canvas) {
    return new TreeView(canvas);
  };

  TreeView.Connection.Router = (function() {

    function Router() {}

    Router.prototype.route = function(conn) {
      throw "Subclasses must implement the method [route]";
    };

    Router.prototype.getDirection = function(r, p) {
      var direction, distance, i;
      distance = Math.abs(r.x - p.x);
      direction = 3;
      i = Math.abs(r.y - p.y);
      if (i <= distance) {
        distance = i;
        direction = 0;
      }
      i = Math.abs(r.getBottom() - p.y);
      if (i <= distance) {
        distance = i;
        direction = 2;
      }
      i = Math.abs(r.getRight() - p.x);
      if (i < distance) {
        distance = i;
        direction = 1;
      }
      return direction;
    };

    Router.prototype.getStartDirection = function(conn) {
      var p, rect;
      p = conn.getStartPoint();
      rect = conn.getSource().getOriginalBBox();
      return this.getDirection(rect, p);
    };

    Router.prototype.getEndDirection = function(conn) {
      var p, rect;
      p = conn.getEndPoint();
      rect = conn.getTarget().getOriginalBBox();
      return this.getDirection(rect, p);
    };

    return Router;

  })();

  TreeView.Connection.DirectRouter = (function(_super) {

    __extends(DirectRouter, _super);

    function DirectRouter() {
      return DirectRouter.__super__.constructor.apply(this, arguments);
    }

    DirectRouter.prototype.route = function(conn) {
      return "M" + (conn.getStartX()) + " " + (conn.getStartY()) + "L" + (conn.getEndX()) + " " + (conn.getEndY());
    };

    return DirectRouter;

  })(TreeView.Connection.Router);

  TreeView.Connection.ManhattanRouter = (function(_super) {
    var MINDIST, TOL, TOLxTOL, buildPoints;

    __extends(ManhattanRouter, _super);

    function ManhattanRouter() {
      return ManhattanRouter.__super__.constructor.apply(this, arguments);
    }

    MINDIST = 20;

    TOL = 0.1;

    TOLxTOL = 0.01;

    ManhattanRouter.prototype.route = function(conn) {
      var fromPt, toPt, xDiff, yDiff;
      fromPt = new Point(conn.getStartX(), conn.getStartY());
      toPt = new Point(conn.getEndX(), conn.getEndY());
      xDiff = fromPt.x - toPt.x;
      yDiff = fromPt.y - toPt.y;
      return "M" + fromPt.x + " " + fromPt.y + "L" + toPt.x + " " + fromPt.y + "L" + toPt.x + " " + toPt.y;
    };

    buildPoints = function(conn, toPt, toDir, fromPt, fromDir) {
      var DOWN, LEFT, RIGHT, UP, dir, point, pos, xDiff, yDiff;
      UP = 0;
      RIGHT = 1;
      DOWN = 2;
      LEFT = 3;
      xDiff = fromPt.x - toPt.x;
      yDiff = fromPt.y - toPt.y;
      point = toPt;
      dir = toDir;
      if (((xDiff * xDiff) < TOLxTOL) && ((yDiff * yDiff) < TOLxTOL)) {
        conn.addPoint(new Point(toPt.x, toPt.y));
        return;
      }
      if (fromDir === LEFT) {
        if ((xDiff > 0) && ((yDiff * yDiff) < TOL) && (toDir === RIGHT)) {
          point = toPt;
          dir = toDir;
        } else {
          if (xDiff < 0) {
            point = new Point(fromPt.x - MINDIST, fromPt.y);
          } else if (((yDiff > 0) && (toDir === DOWN)) || ((yDiff < 0) && (toDir === UP))) {
            point = new Point(toPt.x, fromPt.y);
          } else if (fromDir === toDir) {
            pos = Math.min(fromPt.x, toPt.x) - MINDIST;
            point = new Point(pos, fromPt.y);
          } else {
            point = new Point(fromPt.x - (xDiff / 2), fromPt.y);
          }
          dir = xDiff > 0 ? UP : DOWN;
        }
      } else if (fromDir === RIGHT) {
        if ((xDiff < 0) && ((yDiff * yDiff) < TOL) && (toDir === LEFT)) {
          point = toPt;
          dir = toDir;
        } else {
          if (xDiff > 0) {
            point = new Point(fromPt.x + MINDIST, fromPt.y);
          } else if (((xDiff > 0) && (toDir === DOWN)) || ((yDiff < 0) && (toDir === UP))) {
            point = new Point(toPt.x, fromPt.y);
          } else if (fromDir === toDir) {
            pos = Math.max(fromPt.x, toPt.x) + MINDIST;
            point = new Point(pos, fromPt.y);
          } else {
            point = new Point(fromPt.x - (xDiff / 2), fromPt.y);
          }
          dir = yDiff > 0 ? UP : DOWN;
        }
      } else if (fromDir === DOWN) {
        if (((xDiff * xDiff) < TOL) && (yDiff < 0) && (toDir === UP)) {
          point = toPt;
          dir = toDir;
        } else {
          if (yDiff > 0) {
            point = new Point(fromPt.x, fromPt.y + MINDIST);
          } else if (((xDiff > 0) && (toDir === RIGHT)) || ((xDiff < 0) && (toDir === LEFT))) {
            point = new Point(fromPt.x, toPt.y);
          } else if (fromDir === toDir) {
            pos = Math.max(fromPt.y, toPt.y) + MINDIST;
            point = new Point(fromPt.x, pos);
          } else {
            point = new Point(fromPt.x, fromPt.y - (xDiff / 2));
          }
          dir = xDiff > 0 ? LEFT : RIGHT;
        }
      } else if (fromDir === UP) {
        if (((xDiff * xDiff) < TOL) && (yDiff > 0) && (toDir === DOWN)) {
          point = toPt;
          dir = toDir;
        } else {
          if (yDiff < 0) {
            point = new Point(fromPt.x, fromPt.y - MINDIST);
          } else if (((xDiff > 0) && (toDir === RIGHT)) || ((xDiff < 0) && (toDir === LEFT))) {
            point = new Point(fromPt.x, toPt.y);
          } else if (fromDir === toDir) {
            pos = Math.min(fromPt.y, toPt.y) - MINDIST;
            point = new Point(fromPt.x, pos);
          } else {
            point = new Point(fromPt.x, fromPt.y - (yDiff / 2));
          }
          dir = xDiff > 0 ? LEFT : RIGHT;
        }
      }
      buildPoints(conn, point, dir, toPt, toDir);
      conn.addPoint(fromPt);
    };

    return ManhattanRouter;

  })(TreeView.Connection.Router);

  TreeView.Connection.CurveRouter = (function(_super) {

    __extends(CurveRouter, _super);

    function CurveRouter() {
      return CurveRouter.__super__.constructor.apply(this, arguments);
    }

    CurveRouter.prototype.route = function(conn) {
      var X, Y, d, fromPt, mx, my, toPt;
      fromPt = new Point(conn.getStartX(), conn.getStartY());
      toPt = new Point(conn.getEndX(), conn.getEndY());
      conn.clearPoints();
      X = toPt.x - fromPt.x;
      Y = toPt.y - fromPt.y;
      d = Math.sqrt(X * X + Y * Y);
      mx = (toPt.x + fromPt.x) / 2 - Y * (25 / d + 0.12);
      my = (toPt.y + fromPt.y) / 2 + X * (25 / d + 0.12);
      conn.addPoint(new Point(mx, my));
      return "M" + fromPt.x + " " + fromPt.y + "C" + fromPt.x + " " + fromPt.y + " " + mx + " " + my + " " + toPt.x + " " + toPt.y;
    };

    return CurveRouter;

  })(TreeView.Connection.Router);

  TreeView.Style.TreexStylesheet = (function() {
    var arrowRouter, colors, coordPattern, defaultNode, ptbRouter;

    colors = {
      'edge': '#555555',
      'coord': '#bbbbbb',
      'error': '#ff0000',
      'anode': '#ff6666',
      'anode_coord': '#ff6666',
      'nnode': '#ffff00',
      'tnode': '#4488ff',
      'tnode_coord': '#ccddff',
      'terminal': '#ffff66',
      'terminal_head': '#90ee90',
      'nonterminal_head': '#90ee90',
      'nonterminal': '#ffffe0',
      'trace': '#aaaaaa',
      'current': '#ff0000',
      'coref_gram': '#c05633',
      'coref_text': '#4c509f',
      'compl': '#629f52',
      'alignment': '#bebebe',
      'coindex': '#ffa500',
      'lex': '#006400',
      'aux': '#ff8c00',
      'parenthesis': '#809080',
      'afun': '#00008b',
      'member': '#0000ff',
      'sentmod': '#006400',
      'subfunctor': '#a02818',
      'nodetype': '#00008b',
      'sempos': '#8b008b',
      'phrase': '#00008b',
      'formeme': '#b000b0',
      'tag': '#004048',
      'tag_feat': '#7098A0',
      'clause0': '#ff00ff',
      'clause1': '#ffa500',
      'clause2': '#0000ff',
      'clause3': '#3cb371',
      'clause4': '#ff0000',
      'clause5': '#9932cc',
      'clause6': '#00008b',
      'clause7': '#006400',
      'clause8': '#8b0000',
      'clause9': '#008b8b'
    };

    coordPattern = /^(ADVS|APPS|CONFR|CONJ|CONTRA|CSQ|DISJ|GRAD|OPER|REAS)$/;

    TreexStylesheet.prototype.isCoord = function(node) {
      if (this.layer !== 't') {
        return false;
      }
      return ((node != null ? node.data.functor : void 0) != null) && coordPattern.test(node.data.functor);
    };

    function TreexStylesheet(tree) {
      var _ref;
      this.tree = tree;
      this.layer = (_ref = this.tree.layer.split('-')[1]) != null ? _ref : 'a';
      this.arrows = new ArrayList();
      console.log(this.layer);
      switch (this.layer) {
        case 'p':
          this.styleNode = this.pnodeStyle;
          this.styleConnection = this.pnodeConnection;
          break;
        case 't':
          this.styleNode = this.tnodeStyle;
          this.styleConnection = this.tnodeConnection;
          break;
        default:
          this.styleNode = this.anodeStyle;
          this.styleConnection = this.anodeConnection;
      }
    }

    defaultNode = function(label) {
      var fig;
      fig = new TreeView.Shape.TreeNode(label);
      fig.setDimension(7, 7);
      fig.setStroke(1);
      fig.setColor(colors['edge']);
      return fig;
    };

    TreexStylesheet.prototype.getFigure = function(node) {
      var i, label, labels, _i, _len, _ref;
      labels = (_ref = node.labels) != null ? _ref : [];
      if (this.layer === 't') {
        for (i = _i = 0, _len = labels.length; _i < _len; i = ++_i) {
          label = labels[i];
          labels[i] = label.replace(' ???', '');
        }
      }
      return this.styleNode(node, labels.join("\n"));
    };

    TreexStylesheet.prototype.getConnection = function(parent, child) {
      var conn;
      conn = new TreeView.Connection();
      conn.setStroke(2);
      conn.setColor(colors['edge']);
      this.styleConnection(conn, parent, child);
      return conn;
    };

    TreexStylesheet.prototype.drawArrows = function(node) {
      var arrow, forRemove, ref_attr, target, targetId, targets, _i, _j, _k, _len, _len1, _len2, _ref,
        _this = this;
      _ref = ['coref_gram', 'coref_text', 'compl'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ref_attr = _ref[_i];
        if (node.attr("" + ref_attr + ".rf") != null) {
          targets = node.attr("" + ref_attr + ".rf");
          if (!_.isArray(targets)) {
            targets = [targets];
          }
          for (_j = 0, _len1 = targets.length; _j < _len1; _j++) {
            target = targets[_j];
            targetId = _.isObject(target) ? target['#value'] : target;
            this.arrows.add({
              source_uid: node.uid,
              target_id: targetId,
              type: ref_attr
            });
          }
        }
      }
      forRemove = [];
      this.arrows.each(function(i, arrow) {
        var source, sourceFig, targetFig;
        source = _this.tree.getNodeByUid(arrow.source_uid);
        if (source == null) {
          forRemove.push(arrow);
        }
        target = _this.tree.getNodeById(arrow.target_id);
        if (!((source != null) && (target != null))) {
          return;
        }
        sourceFig = _this.tree.getFigure(source);
        targetFig = _this.tree.getFigure(target);
        if (!((sourceFig != null) && (targetFig != null))) {
          return;
        }
        _this.drawArrow(sourceFig, targetFig, arrow.type);
        forRemove.push(arrow);
      });
      for (_k = 0, _len2 = forRemove.length; _k < _len2; _k++) {
        arrow = forRemove[_k];
        this.arrows.remove(arrow);
      }
    };

    arrowRouter = new TreeView.Connection.CurveRouter();

    TreexStylesheet.prototype.drawArrow = function(sourceFig, targetFig, type) {
      var arrow, conn;
      conn = new TreeView.Connection();
      conn.setSource(sourceFig);
      conn.setTarget(targetFig);
      conn.setColor(colors[type]);
      conn.setStroke(2);
      conn.setRouter(arrowRouter);
      if (type === 'alignment') {
        conn.setStroke(1);
        conn.setDashing('- ');
      }
      arrow = new TreeView.Connection.ArrowDecorator(15, 30);
      arrow.bgColor = conn.getColor();
      conn.setTargetDecorator(arrow);
    };

    TreexStylesheet.prototype.anodeStyle = function(node, label) {
      var fig;
      fig = defaultNode(label);
      fig.setBackgroundColor(colors['anode']);
      return fig;
    };

    TreexStylesheet.prototype.anodeConnection = function(conn, parent, child) {};

    TreexStylesheet.prototype.tnodeStyle = function(node, label) {
      var fig;
      fig = defaultNode(label);
      fig.setBackgroundColor(colors['tnode']);
      if (node.is_root()) {
        return fig;
      }
      if (node.data.is_generated) {
        fig.setNodeShape('rectangle');
      }
      if (this.isCoord(node)) {
        fig.setBackgroundColor(colors['tnode_coord']);
      }
      return fig;
    };

    TreexStylesheet.prototype.tnodeConnection = function(conn, parent, child) {
      var color, dash, functor, width;
      color = colors['edge'];
      width = 2;
      dash = null;
      if (child.data.is_member) {
        if (!child.is_root() && this.isCoord(parent)) {
          width = 1;
          color = colors['coord'];
        } else {
          color = colors['error'];
        }
      } else if (!child.is_root() && this.isCoord(parent)) {
        color = colors['coord_mod'];
      } else if (this.isCoord(child)) {
        color = colors['coord'];
        width = 1;
      }
      functor = child.data.functor != null ? child.data.functor[0]['#value'] : '';
      if (functor.match(/^(PAR|PARTL|VOCAT|RHEM|CM|FPHR|PREC)$/) || (!child.is_root() && parent.is_root())) {
        width = 1;
        dash = '. ';
        color = colors['edge'];
      }
      conn.setStroke(width);
      conn.setColor(color);
      conn.setDashing(dash);
    };

    TreexStylesheet.prototype.pnodeStyle = function(node, label) {
      var ctype, data, fig, terminal;
      data = node.data;
      terminal = node.is_leaf();
      fig = terminal ? defaultNode(label) : new TreeView.Shape.Label(label);
      if (terminal) {
        ctype = data.tag === '-NONE-' ? 'trace' : data.is_head ? 'terminal_head' : 'terminal';
        fig.setLabelAlign('middle');
      } else {
        ctype = data.is_head ? 'nonterminal_head' : 'nonterminal';
        fig.setOpacity(1.0);
        fig.setPadding(2);
        fig.setStroke(1);
        fig.setAnchor('middle');
      }
      fig.setBackgroundColor(colors[ctype]);
      return fig;
    };

    ptbRouter = new TreeView.Connection.ManhattanRouter();

    TreexStylesheet.prototype.pnodeConnection = function(conn, parent, child) {
      conn.setRouter(ptbRouter);
      conn.setStroke(1);
      if (child.is_leaf()) {
        conn.setDashing('- ');
      }
    };

    return TreexStylesheet;

  })();

  TreeView.Layout.GridLayout = (function() {

    function GridLayout(canvas) {
      this.canvas = canvas;
      this.figures = new ArrayList();
      this.reordering = false;
      this.margin = 10;
      this.width = 0;
      this.height = 0;
    }

    GridLayout.prototype.add = function(figure) {
      this.figures.add(figure);
      figure.attachMoveListener(this);
      this.reorderFigures();
    };

    GridLayout.prototype.remove = function(figure) {
      this.figures.remove(figure);
      figure.detachMoveListener(this);
      this.reorderFigures();
    };

    GridLayout.prototype.onOtherFigureIsMoving = function(other) {
      this.reorderFigures();
    };

    GridLayout.prototype.reorderFigures = function() {
      var left,
        _this = this;
      if (this.reordering) {
        return;
      }
      this.reordering = true;
      this.figures.sort(function(fig) {
        var _ref;
        return (_ref = fig.tree) != null ? _ref.layer : void 0;
      });
      left = this.margin;
      this.width = this.height = 0;
      this.figures.each(function(i, fig) {
        var h;
        fig.setPosition(left, 10);
        left += fig.getWidth() + _this.margin;
        h = fig.getAbsoluteY() + fig.getHeight() + _this.margin;
        if (h > _this.height) {
          _this.height = h;
        }
      });
      this.width = left;
      this.reordering = false;
    };

    GridLayout.prototype.getWidth = function() {
      return this.width;
    };

    GridLayout.prototype.getHeight = function() {
      return this.height;
    };

    GridLayout.prototype.enableReordering = function() {
      this.reordering = false;
    };

    GridLayout.prototype.disableReordering = function() {
      this.reordering = true;
    };

    return GridLayout;

  })();

  TreeView.Layout.SimpleTreeLayout = (function() {

    SimpleTreeLayout.prototype.nodeXSkip = 10;

    SimpleTreeLayout.prototype.nodeYSkip = 5;

    SimpleTreeLayout.prototype.marginX = 2;

    SimpleTreeLayout.prototype.marginY = 2;

    function SimpleTreeLayout(tree) {
      this.tree = tree;
      this.grid = {};
      this.order = [];
      this.levelHeights = {};
      this.orderWidths = {};
    }

    SimpleTreeLayout.prototype.populateGrid = function() {
      var i, level, node, _i, _len, _ref;
      this.grid = {};
      this.order = this.tree.getNodes().asArray();
      _ref = this.order;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        node = _ref[i];
        level = node.level();
        if (this.grid[level] == null) {
          this.grid[level] = {};
        }
        this.grid[level][i] = node;
      }
    };

    SimpleTreeLayout.prototype.update = function() {
      this.populateGrid();
      this.computeLevelHeights();
      this.computeOrderWidths();
    };

    SimpleTreeLayout.prototype.computeLevelHeights = function() {
      var figure, height, level, maxLevel, node, x, _i, _ref;
      this.levelHeights = {};
      maxLevel = -1;
      for (level in this.grid) {
        level = parseInt(level);
        if (level > maxLevel) {
          maxLevel = level;
        }
      }
      for (level = _i = 0; _i <= maxLevel; level = _i += 1) {
        this.levelHeights[level] = 0;
        _ref = this.grid[level];
        for (x in _ref) {
          node = _ref[x];
          figure = this.tree.getFigure(node);
          if (figure == null) {
            continue;
          }
          height = figure.getBoundingBox().height;
          if (height > this.levelHeights[level]) {
            this.levelHeights[level] = height;
          }
        }
        this.levelHeights[level] += this.nodeYSkip;
      }
    };

    SimpleTreeLayout.prototype.computeOrderWidths = function() {
      var f, fig, i, index, left, leftWidth, level, n, node, _i, _j, _len, _ref, _ref1;
      this.orderWidths = {};
      left = 0;
      _ref = this.order;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        node = _ref[index];
        if (index === 0) {
          this.orderWidths[index] = left;
          continue;
        }
        fig = this.tree.getFigure(node);
        if (fig == null) {
          continue;
        }
        level = node.level();
        leftWidth = 0;
        for (i = _j = _ref1 = index - 1; _j >= 0; i = _j += -1) {
          n = this.grid[level][i];
          if (n == null) {
            continue;
          }
          f = this.tree.getFigure(n);
          if (f == null) {
            continue;
          }
          leftWidth = this.orderWidths[i] + f.getBoundingBox().width;
          break;
        }
        if (leftWidth >= left) {
          left = leftWidth + this.nodeXSkip;
        } else {
          left += this.nodeXSkip;
        }
        this.orderWidths[index] = left;
      }
    };

    SimpleTreeLayout.prototype.getTotalWidth = function() {
      var f, index, node, w, width, _i, _len, _ref;
      width = 0;
      _ref = this.order;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        node = _ref[index];
        f = this.tree.getFigure(node);
        if (f == null) {
          continue;
        }
        w = this.orderWidths[index] + (index + 2) * this.marginX + f.getBoundingBox().width;
        if (w > width) {
          width = w;
        }
      }
      return width;
    };

    SimpleTreeLayout.prototype.getTotalHeight = function() {
      var height, i, val, _ref;
      height = 0;
      _ref = this.levelHeights;
      for (i in _ref) {
        val = _ref[i];
        height += val + this.marginY;
      }
      return height;
    };

    SimpleTreeLayout.prototype.locator = function(node) {
      return new TreeView.Layout.TreeNodeLocator(this, node);
    };

    SimpleTreeLayout.prototype.getNodePosition = function(node) {
      var level, lvl, orderPos, posX, posY, _i;
      level = node.level();
      posY = this.marginY;
      for (lvl = _i = 0; _i < level; lvl = _i += 1) {
        posY += this.levelHeights[lvl] + this.marginY;
      }
      orderPos = _.indexOf(this.order, node);
      posX = this.marginX + orderPos * this.marginX + this.orderWidths[orderPos];
      return new Point(posX, posY);
    };

    return SimpleTreeLayout;

  })();

  /*
  This tree layout is used mostly for PTB trees.
  
  - uses ManhattanRouter, lines between terminals and non-terminals are dashed
  - terminals are at the bottom
  - non-terminals are squared nodes with label inside; terminals are circular nodes, more like classic PDT nodes
  */


  TreeView.Layout.ConstituencyTreeLayout = (function(_super) {

    __extends(ConstituencyTreeLayout, _super);

    function ConstituencyTreeLayout(tree) {
      ConstituencyTreeLayout.__super__.constructor.call(this, tree);
      this.nodeXSkip = 4;
    }

    ConstituencyTreeLayout.prototype.populateGrid = function() {
      var i, level, node, _i, _len, _ref, _results;
      this.grid = {};
      this.order = this.tree.getNodes().asArray();
      this.maxLevel = _.chain(this.order).map(function(node) {
        return node.level();
      }).max().value();
      _ref = this.order;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        node = _ref[i];
        level = node.is_leaf() ? this.maxLevel : node.level();
        if (this.grid[level] == null) {
          this.grid[level] = {};
        }
        _results.push(this.grid[level][i] = node);
      }
      return _results;
    };

    ConstituencyTreeLayout.prototype.computeOrderWidths = function() {
      var f, fig, i, index, left, leftWidth, level, n, node, _i, _j, _len, _ref, _ref1;
      this.orderWidths = {};
      left = 0;
      _ref = this.order;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        node = _ref[index];
        fig = this.tree.getFigure(node);
        if (fig == null) {
          continue;
        }
        left += fig.getBoundingBox().width / 2;
        if (index === 0) {
          this.orderWidths[0] = left;
          continue;
        }
        level = node.is_leaf() ? this.maxLevel : node.level();
        leftWidth = 0;
        for (i = _j = _ref1 = index - 1; _j >= 0; i = _j += -1) {
          n = this.grid[level][i];
          if (n == null) {
            continue;
          }
          f = this.tree.getFigure(n);
          if (f == null) {
            continue;
          }
          leftWidth = this.orderWidths[i] + f.getBoundingBox().width;
          break;
        }
        if (leftWidth >= left) {
          left = leftWidth + this.nodeXSkip;
        } else {
          left += this.nodeXSkip;
        }
        this.orderWidths[index] = left;
        if (!node.is_root() && node.children().length === 1) {
          left += 15;
        }
      }
    };

    ConstituencyTreeLayout.prototype.getNodePosition = function(node) {
      var level, lvl, orderPos, posX, posY, _i;
      level = node.is_leaf() ? this.maxLevel : node.level();
      posY = this.marginY;
      for (lvl = _i = 0; _i < level; lvl = _i += 1) {
        posY += this.levelHeights[lvl] + this.marginY;
      }
      orderPos = _.indexOf(this.order, node);
      posX = this.marginX + orderPos * this.marginX + this.orderWidths[orderPos];
      return new Point(posX, posY);
    };

    return ConstituencyTreeLayout;

  })(TreeView.Layout.SimpleTreeLayout);

  TreeView.Layout.TreeNodeLocator = (function() {

    function TreeNodeLocator(treeLayout, node) {
      this.treeLayout = treeLayout;
      this.node = node;
    }

    TreeNodeLocator.prototype.relocate = function(order, figure) {
      var pos;
      pos = this.treeLayout.getNodePosition(this.node);
      figure.setPosition(pos.x, pos.y);
    };

    return TreeNodeLocator;

  })();

  TreeView.Layout.BottomLocator = (function() {

    function BottomLocator(parent) {
      this.parent = parent;
      this.anchor = 'start';
    }

    BottomLocator.prototype.relocate = function(order, figure) {
      var bbox, h, stroke, w, x;
      w = this.parent.getWidth();
      h = this.parent.getHeight();
      stroke = this.parent['getStroke'] != null ? this.parent.getStroke() : 0;
      bbox = figure.getBoundingBox();
      switch (this.anchor) {
        case 'middle':
          x = w / 2;
          break;
        case 'end':
          x = w;
          break;
        default:
          x = 0;
      }
      figure.setPosition(x, h + stroke);
    };

    BottomLocator.prototype.setAnchor = function(anchor) {
      this.anchor = anchor;
    };

    BottomLocator.prototype.getAnchor = function() {
      return this.anchor;
    };

    return BottomLocator;

  })();

  /*
  Interactive painting area
  
  Used by TreeView
  Based on graphiti by Andreas Herz
  */


  TreeView.Canvas = (function() {

    function Canvas(canvasId) {
      this.canvasId = canvasId;
      this.html = $("#" + this.canvasId);
      this.initialWidth = this.getWidth();
      this.initialHeight = this.getHeight();
      this.paper = Raphael(this.canvasId, this.getWidth(), this.getHeight());
      this.figures = new ArrayList();
      this.lines = new ArrayList();
      this.currentSelection = null;
      this.zoomFactor = 1.0;
    }

    Canvas.prototype.setLayout = function(layout) {
      this.layout = layout;
    };

    Canvas.prototype.getLayout = function() {
      return this.layout;
    };

    Canvas.prototype.addFigure = function(figure) {
      if (figure.getCanvas() === this) {
        return;
      }
      figure.setCanvas(this);
      if (figure instanceof TreeView.Shape.Line) {
        this.lines.add(figure);
      } else {
        this.figures.add(figure);
        if (this.layout != null) {
          this.layout.add(figure);
        }
      }
      figure.repaint();
    };

    Canvas.prototype.removeFigure = function(figure) {
      this.figures.remove(figure);
      if (this.layout != null) {
        this.layout.remove(figure);
      }
      figure.setCanvas(null);
    };

    Canvas.prototype.getWidth = function() {
      return this.html.width();
    };

    Canvas.prototype.getHeight = function() {
      return this.html.height();
    };

    Canvas.prototype.adjustSize = function() {
      if (this.layout == null) {
        return;
      }
      this.paper.setSize(this.layout.getWidth(), this.layout.getHeight());
    };

    return Canvas;

  })();

  /*
  A lightweight graphical object. Figures are rendered to a Canvas object.
  */


  TreeView.Figure = (function() {

    function Figure() {
      this.id = _.uniqueId('figure_');
      this.canvas = this.shape = null;
      this.x = this.y = 0;
      this.width = this.height = 5;
      this.children = new ArrayList();
      this.moveListener = new ArrayList();
    }

    Figure.prototype.setCanvas = function(canvas) {
      var child, i, _i, _ref;
      if (canvas === null && this.shape !== null) {
        this.shape.remove();
        this.shape = null;
      }
      this.canvas = canvas;
      if (this.canvas !== null) {
        this.getShapeElement();
      }
      for (i = _i = 0, _ref = this.children.getSize(); _i < _ref; i = _i += 1) {
        child = this.children.get(i);
        child.figure.setCanvas(canvas);
      }
    };

    Figure.prototype.getCanvas = function() {
      return this.canvas;
    };

    Figure.prototype.addFigure = function(child, locator) {
      var entry;
      child.setParent(this);
      entry = {
        figure: child,
        locator: locator
      };
      this.children.add(entry);
      if (this.canvas !== null) {
        child.setCanvas(this.canvas);
      }
      this.repaint();
    };

    Figure.prototype.getChildren = function() {
      var shapes,
        _this = this;
      shapes = new ArrayList();
      this.children.each(function(i, e) {
        shapes.add(e.figure);
      });
      return shapes;
    };

    Figure.prototype.resetChildren = function() {
      this.children.each(function(i, e) {
        return e.figure.setCanvas(null);
      });
      this.children = new ArrayList();
      this.repaint();
    };

    Figure.prototype.getShapeElement = function() {
      if (this.shape !== null) {
        return this.shape;
      }
      return this.shape = this.createShapeElement();
    };

    Figure.prototype.createShapeElement = function() {
      throw "Inherited class must override the abstract method createShapeElement";
    };

    Figure.prototype.repaint = function(attrs) {
      var entry, i, _i, _ref;
      if (this.repaintBlocked === true || this.shape === null) {
        return;
      }
      attrs || (attrs = {});
      this.shape.attr(attrs);
      for (i = _i = 0, _ref = this.children.getSize(); _i < _ref; i = _i += 1) {
        entry = this.children.get(i);
        entry.locator.relocate(i, entry.figure);
      }
    };

    Figure.prototype.getWidth = function() {
      return this.width;
    };

    Figure.prototype.getHeight = function() {
      return this.height;
    };

    Figure.prototype.setDimension = function(width, height) {
      this.width = width;
      this.height = height;
      this.repaint();
      this.fireMoveEvent();
    };

    Figure.prototype.getX = function() {
      return this.x;
    };

    Figure.prototype.getY = function() {
      return this.y;
    };

    Figure.prototype.getAbsoluteX = function() {
      if (this.parent == null) {
        return this.getX();
      } else {
        return this.getX() + this.parent.getAbsoluteX();
      }
    };

    Figure.prototype.getAbsoluteY = function() {
      if (this.parent == null) {
        return this.getY();
      } else {
        return this.getY() + this.parent.getAbsoluteY();
      }
    };

    Figure.prototype.getAbsolutePosition = function() {
      return new Point(this.getAbsoluteX(), this.getAbsoluteY());
    };

    Figure.prototype.setPosition = function(x, y) {
      this.x = x;
      this.y = y;
      this.repaint();
      this.fireMoveEvent();
    };

    Figure.prototype.getBoundingBox = function() {
      return new Rectangle(this.getAbsoluteX(), this.getAbsoluteY(), this.getWidth(), this.getHeight());
    };

    Figure.prototype.setParent = function(parent) {
      this.parent = parent;
    };

    Figure.prototype.getParent = function() {
      return this.parent;
    };

    Figure.prototype.attachMoveListener = function(listener) {
      if (listener === null) {
        return;
      }
      this.moveListener.add(listener);
    };

    Figure.prototype.detachMoveListener = function(listener) {
      if (listener === null) {
        return;
      }
      this.moveListener.remove(listener);
    };

    Figure.prototype.fireMoveEvent = function() {
      var _this = this;
      this.moveListener.each(function(i, item) {
        return item.onOtherFigureIsMoving(_this);
      });
    };

    Figure.prototype.onOtherFigureIsMoving = function(other) {};

    return Figure;

  })();

  /*
  A Node class
  */


  TreeView.NodeFigure = (function(_super) {

    __extends(NodeFigure, _super);

    function NodeFigure() {
      this.bgColor = new Color(255, 255, 255);
      this.connections = new ArrayList();
      NodeFigure.__super__.constructor.apply(this, arguments);
    }

    NodeFigure.prototype.addConnection = function(conn) {
      this.connections.add(conn);
      this.attachMoveListener(conn);
    };

    NodeFigure.prototype.removeConnection = function(conn) {
      this.connections.remove(conn);
      this.detachMoveListener(conn);
    };

    NodeFigure.prototype.getConnections = function() {
      return this.connections;
    };

    NodeFigure.prototype.setCanvas = function(canvas) {
      NodeFigure.__super__.setCanvas.call(this, canvas);
      this.connections.each(function(i, connection) {
        connection.setCanvas(canvas);
      });
    };

    NodeFigure.prototype.getAnchorPoint = function() {
      var p;
      p = this.getAbsolutePosition();
      p.x += this.getWidth() / 2;
      p.y += this.getHeight() / 2;
      return p;
    };

    NodeFigure.prototype.getOriginalBBox = function() {
      return new Rectangle(this.getAbsoluteX(), this.getAbsoluteY(), this.getWidth(), this.getHeight());
    };

    NodeFigure.prototype.getBoundingBox = function() {
      var entry, fig, fx, fx2, fy, fy2, i, x, x2, y, y2, _i, _ref;
      x = this.getAbsoluteX();
      y = this.getAbsoluteY();
      x2 = x + this.getWidth();
      y2 = y + this.getHeight();
      for (i = _i = 0, _ref = this.children.getSize(); _i < _ref; i = _i += 1) {
        entry = this.children.get(i);
        fig = entry.figure;
        fx = fig.getAbsoluteX();
        fy = fig.getAbsoluteY();
        fx2 = fx + fig.getBoundingBox().width;
        fy2 = fy + fig.getBoundingBox().height;
        if (fx < x) {
          x = fx;
        }
        if (fy < y) {
          y = fy;
        }
        if (fx2 > x2) {
          x2 = fx2;
        }
        if (fy2 > y2) {
          y2 = fy2;
        }
      }
      return new Rectangle(x, y, x2 - x, y2 - y);
    };

    return NodeFigure;

  })(TreeView.Figure);

  /*
  The base class for all vector based figures
  */


  TreeView.VectorFigure = (function(_super) {

    __extends(VectorFigure, _super);

    function VectorFigure() {
      this.bgColor = new Color(255, 255, 255);
      this.color = new Color(0, 0, 0);
      this.stroke = 1;
      this.opacity = 1.0;
      VectorFigure.__super__.constructor.apply(this, arguments);
    }

    VectorFigure.prototype.repaint = function(attrs) {
      var _ref, _ref1, _ref2, _ref3;
      if (this.repaintBlocked === true || this.shape === null) {
        return;
      }
      attrs || (attrs = {});
      attrs.x = this.getAbsoluteX();
      attrs.y = this.getAbsoluteY();
      if ((_ref = attrs.stroke) == null) {
        attrs.stroke = (this.color != null) && this.stroke === 0 ? 'none' : this.color.getHashStyle();
      }
      if ((_ref1 = attrs['stroke-width']) == null) {
        attrs['stroke-width'] = this.stroke;
      }
      if (this.opacity !== 1.0) {
        if ((_ref2 = attrs['fill-opacity']) == null) {
          attrs['fill-opacity'] = this.opacity;
        }
      }
      if ((_ref3 = attrs.fill) == null) {
        attrs.fill = this.bgColor != null ? this.bgColor.getHashStyle() : 'none';
      }
      VectorFigure.__super__.repaint.call(this, attrs);
    };

    VectorFigure.prototype.setBackgroundColor = function(color) {
      this.bgColor = Color.colorize(color);
      this.repaint();
    };

    VectorFigure.prototype.getBackgroundColor = function() {
      return this.bgColor;
    };

    VectorFigure.prototype.setOpacity = function(opacity) {
      this.opacity = opacity;
      this.repaint();
    };

    VectorFigure.prototype.getOpacity = function() {
      return this.opacity;
    };

    VectorFigure.prototype.setStroke = function(stroke) {
      this.stroke = stroke;
      this.repaint();
    };

    VectorFigure.prototype.getStroke = function() {
      return this.stroke;
    };

    VectorFigure.prototype.setColor = function(color) {
      this.color = Color.colorize(color);
      this.repaint();
    };

    VectorFigure.prototype.getColor = function() {
      return this.color;
    };

    return VectorFigure;

  })(TreeView.NodeFigure);

  /*
  A SetFigure is a composition of different SVG elements.
  */


  TreeView.SetFigure = (function(_super) {

    __extends(SetFigure, _super);

    function SetFigure(width, height) {
      SetFigure.__super__.constructor.apply(this, arguments);
      this.svgNodes = null;
      this.originalWidth = null;
      this.originalHeight = null;
      this.scaleX = 1;
      this.scaleY = 1;
      this.offsetX = 0;
      this.offsetY = 0;
      if (!((width != null) && (height != null))) {
        this.setDimension(50, 50);
      } else {
        this.setDimension(width, height);
      }
    }

    SetFigure.prototype.setCanvas = function(canvas) {
      if (canvas === null && this.svgNodes !== null) {
        this.svgNodes.remove();
        this.svgNodes = null;
      }
      SetFigure.__super__.setCanvas.call(this, canvas);
    };

    SetFigure.prototype.repaint = function(attrs) {
      if (this.repaintBlocked === true || this.shape === null) {
        return;
      }
      attrs || (attrs = {});
      attrs.width = this.getWidth();
      attrs.height = this.getHeight();
      if ((this.originalWidth != null) && (this.originalHeight != null)) {
        this.svgNodes.transform("t" + (this.getAbsoluteX()) + "," + (this.getAbsoluteY()));
      }
      SetFigure.__super__.repaint.call(this, attrs);
    };

    SetFigure.prototype.createShapeElement = function() {
      var bb, shape;
      shape = this.canvas.paper.rect(this.getX(), this.getY(), this.getWidth(), this.getHeight());
      this.svgNodes = this.createSet();
      bb = this.svgNodes.getBBox();
      this.originalWidth = bb.width;
      this.originalHeight = bb.height;
      this.offsetX = Math.abs(bb.x);
      this.offsetY = Math.abs(bb.y);
      return shape;
    };

    SetFigure.prototype.createSet = function() {
      return this.cavas.paper.set();
    };

    return SetFigure;

  })(TreeView.VectorFigure);

  /*
  Holder for a single tree
  */


  TreeView.Tree = (function(_super) {
    var DEFAULT_LAYOUT, DEFAULT_STYLESHEET;

    __extends(Tree, _super);

    DEFAULT_LAYOUT = TreeView.Layout.SimpleTreeLayout;

    DEFAULT_STYLESHEET = TreeView.Style.TreexStylesheet;

    function Tree(layer, tree) {
      var i, node, _i, _len, _ref;
      this.layer = layer;
      this.tree = tree;
      Tree.__super__.constructor.apply(this, arguments);
      this.nodes = new ArrayList();
      this.figures = {};
      this.nodesIndex = {};
      if (this.tree.layer === 'p') {
        this.layout = new TreeView.Layout.ConstituencyTreeLayout(this);
      } else {
        this.layout = new DEFAULT_LAYOUT(this);
      }
      this.style = new DEFAULT_STYLESHEET(this);
      _ref = this.tree.allNodes();
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        node = _ref[i];
        this.addNode(node);
      }
    }

    Tree.prototype.addNode = function(node) {
      var child, figure, i, _i, _len, _ref;
      if (this.figures[node.uid] != null) {
        return;
      }
      this.nodes.add(node);
      this.nodesIndex[node.uid] = node;
      figure = this.style.getFigure(node);
      this.figures[node.uid] = figure;
      this.addFigure(figure, this.layout.locator(node));
      if (!node.is_root() && (this.figures[node.parent.uid] != null)) {
        this.connectNodes(node.parent, node);
      }
      _ref = node.children();
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        child = _ref[i];
        if (this.figures[child.uid] != null) {
          this.connectNodes(node, child);
        }
      }
      this.style.drawArrows(node);
    };

    Tree.prototype.addNodes = function(list) {
      var node, _i, _len;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        node = list[_i];
        this.addNode(node);
      }
    };

    Tree.prototype.getNodeById = function(id) {
      return this.tree.index[id];
    };

    Tree.prototype.getNodeByUid = function(uid) {
      return this.nodesIndex[uid];
    };

    Tree.prototype.connectNodes = function(parent, child) {
      var childFigure, connection, parentFigure;
      parentFigure = this.figures[parent.uid];
      childFigure = this.figures[child.uid];
      if (!((parentFigure != null) && (childFigure != null))) {
        return;
      }
      connection = this.style.getConnection(parent, child);
      if (connection != null) {
        connection.setSource(parentFigure);
        connection.setTarget(childFigure);
      }
    };

    Tree.prototype.getNodes = function() {
      return this.nodes;
    };

    Tree.prototype.getFigure = function(node) {
      return this.figures[node.uid];
    };

    Tree.prototype.getWidth = function() {
      return this.layout.getTotalWidth();
    };

    Tree.prototype.getHeight = function() {
      return this.layout.getTotalHeight();
    };

    Tree.prototype.createShapeElement = function() {
      return this.canvas.paper.rect(this.getX(), this.getY(), this.getWidth(), this.getHeight());
    };

    Tree.prototype.repaint = function(attrs) {
      var entry, i, _i, _ref;
      if (this.repaintBlocked === true || this.shape === null) {
        return;
      }
      this.layout.update();
      for (i = _i = 0, _ref = this.children.getSize(); _i < _ref; i = _i += 1) {
        entry = this.children.get(i);
        entry.locator.relocate(i, entry.figure);
      }
      attrs || (attrs = {});
      attrs.x = this.getAbsoluteX();
      attrs.y = this.getAbsoluteY();
      attrs.width = this.getWidth();
      attrs.height = this.getHeight();
      attrs.stroke = 'none';
      this.shape.attr(attrs);
    };

    return Tree;

  })(TreeView.Figure);

  /*
  The base class for all visible elements inside a canvas.
  */


  TreeView.Shape.Line = (function(_super) {
    var DEFAULT_COLOR;

    __extends(Line, _super);

    DEFAULT_COLOR = new Color(0, 0, 0);

    function Line(startX, startY, endX, endY) {
      this.startX = startX;
      this.startY = startY;
      this.endX = endX;
      this.endY = endY;
      this.lineColor = DEFAULT_COLOR;
      this.stroke = 1;
      this.dashing = null;
      Line.__super__.constructor.apply(this, arguments);
    }

    Line.prototype.getStartX = function() {
      return this.startX;
    };

    Line.prototype.getStartY = function() {
      return this.startY;
    };

    Line.prototype.getEndX = function() {
      return this.endX;
    };

    Line.prototype.getEndY = function() {
      return this.endY;
    };

    Line.prototype.getStartPoint = function() {
      return new Point(this.getStartX(), this.getStartY());
    };

    Line.prototype.getEndPoint = function() {
      return new Point(this.getEndX(), this.getEndY());
    };

    Line.prototype.setStartPoint = function(x, y) {
      if (this.startX === x && this.startY === y) {
        return;
      }
      this.startX = x;
      this.startY = y;
      this.repaint();
    };

    Line.prototype.setEndPoint = function(x, y) {
      if (this.endX === x && this.endY === y) {
        return;
      }
      this.endX = x;
      this.endY = y;
      this.repaint();
    };

    Line.prototype.getSegments = function() {
      var res;
      res = new ArrayList();
      res.add({
        start: this.getStartPoint(),
        end: this.getEndPoint()
      });
      return res;
    };

    Line.prototype.getLength = function() {
      if (this.shape !== null) {
        return this.shape.getTotalLength();
      }
      return Math.sqrt((this.startX - this.endX) * (this.startX - this.endX) + (this.startY - this.endY) * (this.startY - this.endY));
    };

    Line.prototype.getPathString = function() {
      return "M" + (this.getStartX()) + " " + (this.getStartY()) + "L" + (this.getEndX()) + " " + (this.getEndY());
    };

    Line.prototype.createShapeElement = function() {
      return this.canvas.paper.path(this.getPathString());
    };

    Line.prototype.repaint = function(attrs) {
      var _ref, _ref1;
      if (this.repaintBlocked === true || this.shape === null) {
        return;
      }
      if (attrs == null) {
        attrs = {
          'stroke': this.lineColor.getHashStyle(),
          'stroke-width': this.stroke,
          'path': this.getPathString()
        };
      } else {
        if ((_ref = attrs.path) == null) {
          attrs.path = this.getPathString();
        }
        attrs.stroke = this.lineColor.getHashStyle();
        attrs['stroke-width'] = this.stroke;
      }
      if (this.dashing != null) {
        if ((_ref1 = attrs['stroke-dasharray']) == null) {
          attrs['stroke-dasharray'] = this.dashing;
        }
      }
      attrs['stroke-linecap'] = 'butt';
      attrs['stroke-linejoin'] = 'round';
      Line.__super__.repaint.call(this, attrs);
    };

    Line.prototype.setStroke = function(stroke) {
      this.stroke = stroke;
    };

    Line.prototype.getStroke = function() {
      return this.stroke;
    };

    Line.prototype.setDashing = function(dashing) {
      this.dashing = dashing;
    };

    Line.prototype.getDashing = function() {
      return this.dashing;
    };

    Line.prototype.setColor = function(color) {
      if (color instanceof Color) {
        this.lineColor = color;
      } else if (typeof color === 'string') {
        this.lineColor = new Color(color);
      } else {
        this.lineColor = DEFAULT_COLOR;
      }
      this.repaint();
    };

    Line.prototype.getColor = function() {
      return this.lineColor;
    };

    return Line;

  })(TreeView.Figure);

  /*
  A PolyLine is a line with more than 2 points.
  */


  TreeView.Shape.PolyLine = (function(_super) {

    __extends(PolyLine, _super);

    function PolyLine() {
      this.svgPathString = null;
      this.lineSegments = new ArrayList();
      this.basePoints = new ArrayList();
      this.lastPoint = null;
      PolyLine.__super__.constructor.apply(this, arguments);
      this.setStroke(1);
    }

    PolyLine.prototype.setStartPoint = function(x, y) {
      PolyLine.__super__.setStartPoint.call(this, x, y);
      this.calculatePath();
      this.repaint();
    };

    PolyLine.prototype.setEndPoint = function(x, y) {
      PolyLine.__super__.setEndPoint.call(this, x, y);
      this.calculatePath();
      this.repaint();
    };

    PolyLine.prototype.getPoints = function() {
      return this.basePoints;
    };

    PolyLine.prototype.getSegments = function() {
      return this.lineSegments;
    };

    PolyLine.prototype.clearPoints = function() {
      this.basePoints.removeAllElements();
      this.lineSegments.removeAllElements();
      this.lastPoint = null;
    };

    PolyLine.prototype.addPoint = function(point) {
      var p;
      p = new Point(point.x, point.y);
      this.basePoints.add(p);
      if (this.lastPoint !== null) {
        this.lineSegments.add({
          start: this.lastPoint,
          end: p
        });
      }
      this.lastPoint = p;
    };

    PolyLine.prototype.getPathString = function() {
      if (this.svgPathString == null) {
        this.calculatePath();
      }
      return this.svgPathString;
    };

    PolyLine.prototype.calculatePath = function() {
      var _this = this;
      if (this.shape === null) {
        return;
      }
      this.svgPathString = "M" + (this.getStartX()) + " " + (this.getStartY());
      this.basePoints.each(function(i, p) {
        return _this.svgPathString += "L" + p.x + " " + p.y;
      });
      this.svgPathString += "L" + (this.getEndX()) + " " + (this.getEndY());
    };

    PolyLine.prototype.repaint = function() {
      if (this.repaintBlocked === true || this.shape === null) {
        return;
      }
      if (this.svgPathString === null) {
        this.calculatePath();
      }
      PolyLine.__super__.repaint.call(this, {
        path: this.svgPathString
      });
    };

    return PolyLine;

  })(TreeView.Shape.Line);

  /*
  A Rectangle Figure.
  */


  TreeView.Shape.Rectangle = (function(_super) {

    __extends(Rectangle, _super);

    function Rectangle(width, height) {
      this.radius = 0;
      Rectangle.__super__.constructor.apply(this, arguments);
      if (!((width != null) && (height != null))) {
        this.setDimension(50, 50);
      } else {
        this.setDimension(width, height);
      }
    }

    Rectangle.prototype.repaint = function(attrs) {
      if (this.repaintBlocked === true || this.shape === null) {
        return;
      }
      attrs || (attrs = {});
      attrs.width = this.getWidth();
      attrs.height = this.getHeight();
      attrs.r = this.radius;
      Rectangle.__super__.repaint.call(this, attrs);
    };

    Rectangle.prototype.createShapeElement = function() {
      return this.canvas.paper.rect(this.getX(), this.getY(), this.getWidth(), this.getHeight());
    };

    Rectangle.prototype.setRadius = function(radius) {
      this.radius = radius;
      this.repaint;
    };

    Rectangle.prototype.getRadius = function() {
      return this.radius;
    };

    return Rectangle;

  })(TreeView.VectorFigure);

  TreeView.Shape.Oval = (function(_super) {

    __extends(Oval, _super);

    function Oval(width, height) {
      Oval.__super__.constructor.apply(this, arguments);
      if ((width != null) && (height != null)) {
        this.setDimension(width, height);
      } else {
        this.setDimension(50, 50);
      }
    }

    Oval.prototype.createShapeElement = function() {
      var halfH, halfW;
      halfW = this.getWidth() / 2;
      halfH = this.getHeight() / 2;
      return this.canvas.paper.ellipse(this.getAbsoluteX() + halfW, this.getAbsoluteY() + halfH, halfW, halfW);
    };

    Oval.prototype.repaint = function(attrs) {
      if (this.repaintBlocked === true || this.shape === null) {
        return;
      }
      attrs || (attrs = {});
      if (!((attrs.rx != null) && (attrs.ry != null))) {
        attrs.rx = this.getWidth() / 2;
        attrs.ry = this.getHeight() / 2;
      }
      if (!((attrs.cx != null) && (attrs.cy != null))) {
        attrs.cx = this.getAbsoluteX() + attrs.rx;
        attrs.cy = this.getAbsoluteY() + attrs.ry;
      }
      Oval.__super__.repaint.call(this, attrs);
    };

    return Oval;

  })(TreeView.VectorFigure);

  TreeView.Shape.Circle = (function(_super) {

    __extends(Circle, _super);

    function Circle(radius) {
      this.radius = radius;
      Circle.__super__.constructor.apply(this, arguments);
      if (this.radius != null) {
        this.setDimension(this.radius, this.radius);
      } else {
        this.setDimension(50, 50);
      }
    }

    Circle.prototype.setDimension = function(w, h) {
      if (w > h) {
        Circle.__super__.setDimension.call(this, w, w);
      } else {
        Circle.__super__.setDimension.call(this, h, h);
      }
    };

    return Circle;

  })(TreeView.Shape.Oval);

  TreeView.Shape.TreeNode = (function(_super) {

    __extends(TreeNode, _super);

    function TreeNode(label) {
      this.label = label;
      TreeNode.__super__.constructor.apply(this, arguments);
      this.shapeName = 'circle';
      this.labelFigure = new TreeView.Shape.Label(this.label);
      this.labelLocator = new TreeView.Layout.BottomLocator(this);
      this.addFigure(this.labelFigure, this.labelLocator);
    }

    TreeNode.prototype.repaint = function(attrs) {
      var h, w, _ref;
      if (this.repaintBlocked === true || this.shape === null) {
        return;
      }
      attrs || (attrs = {});
      w = this.getWidth();
      h = this.getHeight();
      if (this.shapeName === 'circle') {
        if (h > w) {
          w = h;
        }
        if (w > h) {
          h = w;
        }
      }
      if ((_ref = this.shapeName) === 'circle' || _ref === 'ellipse') {
        if (!((attrs.rx != null) && (attrs.ry != null))) {
          attrs.rx = w / 2;
          attrs.ry = h / 2;
        }
        if (!((attrs.cx != null) && (attrs.cy != null))) {
          attrs.cx = this.getAbsoluteX() + attrs.rx;
          attrs.cy = this.getAbsoluteY() + attrs.ry;
        }
      } else if (this.shapeName === 'rectangle') {
        attrs.width = w;
        attrs.height = h;
      }
      TreeNode.__super__.repaint.call(this, attrs);
    };

    TreeNode.prototype.createShapeElement = function() {
      var h, r, rx, ry, w;
      w = this.getWidth();
      h = this.getHeight();
      switch (this.shapeName) {
        case 'circle':
          r = (w > h ? w : h) / 2;
          return this.canvas.paper.circle(this.getAbsoluteX() + r, this.getAbsoluteY() + r, r);
        case 'ellipse':
          rx = w / 2;
          ry = h / 2;
          return this.canvas.paper.ellipse(this.getAbsoluteX() + rx, this.getAbsoluteY() + ry, rx, ry);
        case 'rectangle':
          return this.canvas.paper.rect(this.getAbsoluteX(), this.getAbsoluteY(), w, h);
      }
    };

    TreeNode.prototype.setLabel = function(label) {
      this.label = label;
      this.labelFigure.setText(this.label);
    };

    TreeNode.prototype.getLabel = function() {
      return this.labelFigure;
    };

    TreeNode.prototype.setLabelAlign = function(anchor) {
      this.labelFigure.setAnchor(anchor);
      this.labelLocator.setAnchor(anchor);
    };

    TreeNode.prototype.getLabelAlign = function() {
      return this.labelFigure.getAnchor();
    };

    TreeNode.prototype.setNodeShape = function(shapeName) {
      this.shapeName = shapeName;
    };

    TreeNode.prototype.getNodeShape = function() {
      return this.shapeName;
    };

    return TreeNode;

  })(TreeView.VectorFigure);

  TreeView.Shape.Label = (function(_super) {

    __extends(Label, _super);

    function Label(text) {
      this.text = text;
      Label.__super__.constructor.apply(this, arguments);
      if (!((this.text != null) && typeof this.text === 'string')) {
        this.text = '';
      }
      this.fontSize = 12;
      this.fontColor = new Color(0, 0, 0);
      this.padding = 1;
      this.opacity = 0.9;
      this.anchor = 'start';
      this.setStroke(0);
    }

    Label.prototype.createSet = function() {
      return this.canvas.paper.text(0, 0, this.text);
    };

    Label.prototype.repaint = function(attrs) {
      var lattrs;
      if (this.repaintBlocked === true || !(this.shape != null)) {
        return;
      }
      attrs || (attrs = {});
      lattrs = {
        text: this.getText(),
        x: this.padding,
        y: this.getHeight() / 2,
        'text-anchor': this.anchor,
        'font-size': this.getFontSize(),
        fill: this.getFontColor().getHashStyle()
      };
      this.svgNodes.attr(lattrs);
      Label.__super__.repaint.call(this, attrs);
      switch (this.anchor) {
        case 'middle':
          this.svgNodes.transform("t" + (this.getAbsoluteX() + this.getWidth() / 2 - this.padding) + "," + (this.getAbsoluteY()));
          break;
        case 'end':
          this.svgNodes.transform("t" + (this.getAbsoluteX() - this.getWidth() + this.padding) + "," + (this.getAbsoluteY()));
      }
    };

    Label.prototype.setPadding = function(padding) {
      this.padding = padding;
    };

    Label.prototype.getPadding = function() {
      return this.padding;
    };

    Label.prototype.setAnchor = function(anchor) {
      this.anchor = anchor;
    };

    Label.prototype.getAnchor = function() {
      return this.anchor;
    };

    Label.prototype.setText = function(text) {
      this.text = text;
    };

    Label.prototype.getText = function() {
      return this.text;
    };

    Label.prototype.setFontSize = function(fontSize) {
      this.fontSize = fontSize;
    };

    Label.prototype.getFontSize = function() {
      return this.fontSize;
    };

    Label.prototype.setFontColor = function(color) {
      this.fontColor = Color.colorize(color);
    };

    Label.prototype.getFontColor = function() {
      return this.fontColor;
    };

    Label.prototype.getWidth = function() {
      if (this.shape === null) {
        return 0;
      }
      return this.svgNodes.getBBox().width + this.padding * 2;
    };

    Label.prototype.getHeight = function() {
      if (this.shape === null) {
        return 0;
      }
      return this.svgNodes.getBBox().height;
    };

    Label.prototype.getX = function() {
      switch (this.anchor) {
        case 'middle':
          return this.x - this.getWidth() / 2;
        case 'end':
          return this.x + this.getWidth();
        default:
          return this.x;
      }
    };

    return Label;

  })(TreeView.SetFigure);

  /*
  An object to which a TreeView.Connection will be anchored.
  */


  TreeView.ConnectionAnchor = (function() {

    function ConnectionAnchor(owner) {
      this.owner = owner;
      if (this.owner == null) {
        throw "Missing owner for ConnectionAnchor";
      }
    }

    ConnectionAnchor.prototype.getX = function() {
      return this.getLocation().x;
    };

    ConnectionAnchor.prototype.getY = function() {
      return this.getLocation().y;
    };

    ConnectionAnchor.prototype.getLocation = function() {
      return this.owner.getAnchorPoint();
    };

    ConnectionAnchor.prototype.setOwner = function(owner) {
      this.owner = owner;
    };

    ConnectionAnchor.prototype.getOwner = function() {
      return this.owner;
    };

    ConnectionAnchor.prototype.getBox = function() {
      return this.getOwner().getAbsoluteBounds();
    };

    ConnectionAnchor.prototype.getReferencePoint = function() {
      return this.getOwner().getAbsolutePosition();
    };

    return ConnectionAnchor;

  })();

  /*
  A Connection is the line between two Nodes.
  */


  TreeView.Connection = (function(_super) {
    var DEFAULT_ROUTER;

    __extends(Connection, _super);

    DEFAULT_ROUTER = new TreeView.Connection.DirectRouter();

    function Connection() {
      Connection.__super__.constructor.apply(this, arguments);
      this.sourceNode = null;
      this.targetNode = null;
      this.sourceDecorator = null;
      this.startDecoratorSet = null;
      this.targetDecorator = null;
      this.endDecoratorSet = null;
      this.sourceAnchor = new TreeView.ConnectionAnchor(this);
      this.targetAnchor = new TreeView.ConnectionAnchor(this);
      this.router = DEFAULT_ROUTER;
    }

    Connection.prototype.disconnet = function() {
      if (this.sourceNode !== null) {
        this.sourceNode.detachMoveListener(this);
      }
      if (this.targetNode !== null) {
        this.targetNode.detachMoveListener(this);
      }
    };

    Connection.prototype.reconnect = function() {
      if (this.sourceNode !== null) {
        this.sourceNode.attachMoveListener(this);
      }
      if (this.targetNode !== null) {
        this.targetNode.attachMoveListener(this);
      }
      this.repaint();
    };

    Connection.prototype.setRouter = function(router) {
      this.router = router;
    };

    Connection.prototype.getRouter = function() {
      return this.router;
    };

    Connection.prototype.addFigure = function(child, locator) {
      if (!(locator instanceof TreeView.Layout.ConnectionLocator)) {
        throw "Locator must implement TreeView.Layout.ConnectionLocator";
      }
      Connection.__super__.addFigure.call(this, child, locator);
    };

    Connection.prototype.getStartX = function() {
      return this.sourceAnchor.getX();
    };

    Connection.prototype.getStartY = function() {
      return this.sourceAnchor.getY();
    };

    Connection.prototype.getEndX = function() {
      return this.targetAnchor.getX();
    };

    Connection.prototype.getEndY = function() {
      return this.targetAnchor.getY();
    };

    Connection.prototype.calculatePath = function() {
      if (this.shape === null) {
        return;
      }
      this.svgPathString = this.router.route(this);
    };

    Connection.prototype.repaint = function(attrs) {
      var angle, c, ex, ey, p, sx, sy;
      if (this.repaintBlocked === true || this.shape === null || !(this.sourceNode != null) || !(this.targetNode != null)) {
        return;
      }
      this.shape.toBack();
      Connection.__super__.repaint.call(this, attrs);
      this.svgPathString = null;
      if ((this.targetDecorator != null) && this.endDecoratorSet === null) {
        this.endDecoratorSet = this.targetDecorator.paint(this.getCanvas().paper);
        this.endDecoratorSet.insertAfter(this.shape);
      }
      if ((this.sourceDecorator != null) && this.startDecoratorSet === null) {
        this.startDecoratorSet = this.sourceDecorator.paint(this.getCanvas().paper);
        this.startDecoratorSet.insertAfter(this.shape);
      }
      if ((this.startDecoratorSet != null) || (this.endDecoratorSet != null)) {
        sx = this.getStartX();
        sy = this.getStartY();
        ex = this.getEndX();
        ey = this.getEndY();
        if (this.startDecoratorSet != null) {
          if (this.basePoints.getSize() > 0) {
            c = this.basePoints.getFirstElement();
            p = Raphael.findDotsAtSegment(sx, sy, c.x, c.y, c.x, c.y, ex, ey, 0.05);
            angle = Raphael.angle(sx, sy, p.x, p.y);
          } else {
            angle = Raphael.angle(sx, sy, ex, ey);
          }
          this.startDecoratorSet.transform("r" + angle + "," + sx + "," + sy + " t" + sx + " " + sy);
        }
        if (this.endDecoratorSet != null) {
          if (this.basePoints.getSize() > 0) {
            c = this.basePoints.getLastElement();
            p = Raphael.findDotsAtSegment(sx, sy, c.x, c.y, c.x, c.y, ex, ey, 0.95);
            angle = Raphael.angle(ex, ey, p.x, p.y);
          } else {
            angle = Raphael.angle(ex, ey, sx, sy);
          }
          this.endDecoratorSet.transform("r" + angle + "," + ex + "," + ey + " t" + ex + " " + ey);
        }
      }
    };

    Connection.prototype.setSourceDecorator = function(sourceDecorator) {
      this.sourceDecorator = sourceDecorator;
      this.repaint();
    };

    Connection.prototype.getSourceDecorator = function() {
      return this.sourceDecorator;
    };

    Connection.prototype.setTargetDecorator = function(targetDecorator) {
      this.targetDecorator = targetDecorator;
      this.repaint();
    };

    Connection.prototype.getTargetDecorator = function() {
      return this.targetDecorator;
    };

    Connection.prototype.setSource = function(node) {
      if (this.sourceNode != null) {
        this.sourceNode.removeConnection(this);
        this.sourceAnchor.setOwner(this);
        this.setCanvas(null);
      }
      this.sourceNode = node;
      node.addConnection(this);
      this.sourceAnchor.setOwner(node);
      this.setCanvas(node.getCanvas());
      this.repaint();
    };

    Connection.prototype.getSource = function() {
      return this.sourceNode;
    };

    Connection.prototype.setTarget = function(node) {
      if (this.targetNode != null) {
        this.targetNode.removeConnection(this);
        this.targetAnchor.setOwner(this);
        this.setCanvas(null);
      }
      this.targetNode = node;
      node.addConnection(this);
      this.targetAnchor.setOwner(node);
      this.setCanvas(node.getCanvas());
      this.repaint();
    };

    Connection.prototype.getTarget = function() {
      return this.targetNode;
    };

    Connection.prototype.onOtherFigureIsMoving = function(other) {
      if (other === this.sourceNode || other === this.targetNode) {
        this.repaint();
      }
    };

    return Connection;

  })(TreeView.Shape.PolyLine);

  TreeView.Connection.ArrowDecorator = (function() {

    function ArrowDecorator() {
      this.width = 16;
      this.height = 8;
      this.color = new Color(0, 0, 0);
      this.bgColor = new Color(250, 250, 250);
    }

    ArrowDecorator.prototype.paint = function(paper) {
      var path, st;
      st = paper.set();
      path = "M 0 0L-18 -4L-16 0L-18 4Z";
      st.push(paper.path(path));
      st.attr({
        fill: this.bgColor.getHashStyle(),
        stroke: this.bgColor.getHashStyle()
      });
      return st;
    };

    return ArrowDecorator;

  })();

}).call(this);
